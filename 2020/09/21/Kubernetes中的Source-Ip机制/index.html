<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"damonyi.cc","root":"/","images":"/images","scheme":"Muse","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="准备工作你必须拥有一个正常工作的 Kubernetes 1.5 集群，用来运行本文中的示例。该示例使用一个简单的 nginx webserver 回送它接收到的请求的 HTTP 头中的源 IP 地址。你可以像下面这样创建它： 12$ kubectl run source-ip-app --image&#x3D;k8s.gcr.io&#x2F;echoserver:1.4deployment &amp;qu">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes中的Source Ip机制">
<meta property="og:url" content="http://damonyi.cc/2020/09/21/Kubernetes%E4%B8%AD%E7%9A%84Source-Ip%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="云里雾里">
<meta property="og:description" content="准备工作你必须拥有一个正常工作的 Kubernetes 1.5 集群，用来运行本文中的示例。该示例使用一个简单的 nginx webserver 回送它接收到的请求的 HTTP 头中的源 IP 地址。你可以像下面这样创建它： 12$ kubectl run source-ip-app --image&#x3D;k8s.gcr.io&#x2F;echoserver:1.4deployment &amp;qu">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://damonyi.cc/2020/09/21/Kubernetes%E4%B8%AD%E7%9A%84Source-Ip%E6%9C%BA%E5%88%B6/1526621848885868.png">
<meta property="og:image" content="http://damonyi.cc/2020/09/21/Kubernetes%E4%B8%AD%E7%9A%84Source-Ip%E6%9C%BA%E5%88%B6/1526622213101501.png">
<meta property="og:image" content="http://damonyi.cc/2020/09/21/Kubernetes%E4%B8%AD%E7%9A%84Source-Ip%E6%9C%BA%E5%88%B6/1526622380157076.png">
<meta property="article:published_time" content="2020-09-21T11:11:11.000Z">
<meta property="article:modified_time" content="2020-09-21T11:23:08.213Z">
<meta property="article:tag" content="kubernetes 网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://damonyi.cc/2020/09/21/Kubernetes%E4%B8%AD%E7%9A%84Source-Ip%E6%9C%BA%E5%88%B6/1526621848885868.png">


<link rel="canonical" href="http://damonyi.cc/2020/09/21/Kubernetes%E4%B8%AD%E7%9A%84Source-Ip%E6%9C%BA%E5%88%B6/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>Kubernetes中的Source Ip机制 | 云里雾里</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">云里雾里</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Type-ClusterIP-%E7%B1%BB%E5%9E%8B-Services-%E7%9A%84-Source-IP"><span class="nav-number">2.</span> <span class="nav-text">Type&#x3D;ClusterIP 类型 Services 的 Source IP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Type-NodePort-%E7%B1%BB%E5%9E%8B-Services-%E7%9A%84-Source-IP"><span class="nav-number">3.</span> <span class="nav-text">Type&#x3D;NodePort 类型 Services 的 Source IP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Type-LoadBalancer-%E7%B1%BB%E5%9E%8B-Services-%E7%9A%84-Source-IP"><span class="nav-number">4.</span> <span class="nav-text">Type&#x3D;LoadBalancer 类型 Services 的 Source IP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%94%AF%E6%8C%81"><span class="nav-number">5.</span> <span class="nav-text">跨平台支持</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">雾里云里</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://damonyi.cc/2020/09/21/Kubernetes%E4%B8%AD%E7%9A%84Source-Ip%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="雾里云里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="云里雾里">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Kubernetes中的Source Ip机制
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-09-21 19:11:11 / 修改时间：19:23:08" itemprop="dateCreated datePublished" datetime="2020-09-21T19:11:11+08:00">2020-09-21</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>你必须拥有一个正常工作的 Kubernetes 1.5 集群，用来运行本文中的示例。该示例使用一个简单的 nginx webserver 回送它接收到的请求的 HTTP 头中的源 IP 地址。你可以像下面这样创建它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run source-ip-app --image&#x3D;k8s.gcr.io&#x2F;echoserver:1.4</span><br><span class="line">deployment &quot;source-ip-app&quot; created</span><br></pre></td></tr></table></figure>

<h2 id="Type-ClusterIP-类型-Services-的-Source-IP"><a href="#Type-ClusterIP-类型-Services-的-Source-IP" class="headerlink" title="Type=ClusterIP 类型 Services 的 Source IP"></a>Type=ClusterIP 类型 Services 的 Source IP</h2><p>如果你的 kube-proxy 运行在 iptables 模式下，从集群内部发送到 ClusterIP 的包永远不会进行源地址 NAT，这从 Kubernetes 1.2 开始是默认选项。Kube-proxy 通过一个 proxyMode endpoint 暴露它的模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME                           STATUS     AGE     VERSION</span><br><span class="line">kubernetes-minion-group-6jst   Ready      2h      v1.6.0+fff5156</span><br><span class="line">kubernetes-minion-group-cx31   Ready      2h      v1.6.0+fff5156</span><br><span class="line">kubernetes-minion-group-jj1t   Ready      2h      v1.6.0+fff5156</span><br><span class="line">kubernetes-minion-group-6jst $ curl localhost:10249&#x2F;proxyMode</span><br><span class="line">iptables</span><br></pre></td></tr></table></figure>

<p>你可以通过在 source IP 应用上创建一个服务来测试源 IP 保留。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl expose deployment source-ip-app --name&#x3D;clusterip --port&#x3D;80 --target-port&#x3D;8080</span><br><span class="line">service &quot;clusterip&quot; exposed</span><br><span class="line"></span><br><span class="line">$ kubectl get svc clusterip</span><br><span class="line">NAME         CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">clusterip    10.0.170.92   &lt;none&gt;        80&#x2F;TCP    51s</span><br><span class="line">&#96;&#96;&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">从相同集群中的一个 pod 访问这个 ClusterIP：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$ kubectl run busybox -it –image=busybox –restart=Never –rm<br>Waiting for pod default/busybox to be running, status is Pending, pod ready: false<br>If you don’t see a command prompt, try pressing enter.<br># ip addr<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1/128 scope host<br>       valid_lft forever preferred_lft forever<br>3: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1460 qdisc noqueue<br>    link/ether 0a:58:0a:f4:03:08 brd ff:ff:ff:ff:ff:ff<br>    inet 10.244.3.8/24 scope global eth0<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::188a:84ff:feb0:26a5/64 scope link<br>       valid_lft forever preferred_lft forever</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p># wget -qO - 10.0.170.92<br>CLIENT VALUES:<br>client_address=10.244.3.8<br>command=GET<br>…</p>
<p>````</p>
<p>如果客户端 pod 和 服务端 pod 在相同的节点上，client_address 就是客户端 pod 的 IP 地址。但是，如果它们在不同的节点上， client_address 将会是客户端 pod 所在节点的 flannel IP 地址。</p>
<h2 id="Type-NodePort-类型-Services-的-Source-IP"><a href="#Type-NodePort-类型-Services-的-Source-IP" class="headerlink" title="Type=NodePort 类型 Services 的 Source IP"></a>Type=NodePort 类型 Services 的 Source IP</h2><p>      对于 Kubernetes 1.5，发送给类型为 Type=NodePort Services 的数据包默认进行源地址 NAT。你可以创建一个 NodePort Service 来进行测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl expose deployment source-ip-app --name&#x3D;nodeport --port&#x3D;80 --target-port&#x3D;8080 --type&#x3D;NodePort</span><br><span class="line">service &quot;nodeport&quot; exposed</span><br><span class="line">$ NODEPORT&#x3D;$(kubectl get -o jsonpath&#x3D;&quot;&#123;.spec.ports\[0\].nodePort&#125;&quot; services nodeport)</span><br><span class="line">$ NODES&#x3D;$(kubectl get nodes -o jsonpath&#x3D;&#39;&#123; $.items\[\*\].status.addresses\[?(@.type&#x3D;&#x3D;&quot;ExternalIP&quot;)\].address &#125;&#39;)</span><br></pre></td></tr></table></figure>

<p>如果你的集群运行在一个云服务上，你可能需要为上面报告的 nodes:nodeport 开启一条防火墙规则。 现在，你可以通过上面分配的节点端口从外部访问这个 Service。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ for node in $NODES; do curl -s $node:$NODEPORT | grep -i client\_address; done</span><br><span class="line">client\_address&#x3D;10.180.1.1</span><br><span class="line">client\_address&#x3D;10.240.0.5</span><br><span class="line">client\_address&#x3D;10.240.0.3</span><br></pre></td></tr></table></figure>

<p>请注意，这些并不是正确的客户端 IP，它们是集群的内部 IP。这是所发生的事情：</p>
<p>1、客户端发送数据包到 node2:nodePort</p>
<p>2、node2 使用它自己的 IP 地址替换数据包的源 IP 地址（SNAT）</p>
<p>3、node2 使用 pod IP 地址替换数据包的目的 IP 地址</p>
<p>4、数据包被路由到 node 1，然后交给 endpoint</p>
<p>5、Pod 的回复被路由回 node2</p>
<p>6、Pod 的回复被发送回给客户端</p>
<p>形象的：<br> <img src="/2020/09/21/Kubernetes%E4%B8%AD%E7%9A%84Source-Ip%E6%9C%BA%E5%88%B6/1526621848885868.png" alt="avatar"></p>
<p>      为了防止这种情况发生，Kubernetes 提供了一个特性来保留客户端的源 IP 地址(点击此处查看可用特性)。设置 service.spec.externalTrafficPolicy 的值为 Local，请求就只会被代理到本地 endpoints 而不会被转发到其它节点。这样就保留了最初的源 IP 地址。如果没有本地 endpoints，发送到这个节点的数据包将会被丢弃。这样在应用到数据包的任何包处理规则下，你都能依赖这个正确的 source-ip 使数据包通过并到达 endpoint。</p>
<p>   设置 service.spec.externalTrafficPolicy 字段如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl patch svc nodeport -p &#39;&#123;&quot;spec&quot;:&#123;&quot;externalTrafficPolicy&quot;:&quot;Local&quot;&#125;&#125;&#39;</span><br><span class="line">service &quot;nodeport&quot; patched</span><br></pre></td></tr></table></figure>

<p>现在，重新运行测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ for node in $NODES; do curl --connect-timeout 1 -s $node:$NODEPORT | grep -i client\_address; done</span><br><span class="line">client\_address&#x3D;104.132.1.79</span><br></pre></td></tr></table></figure>

<p>   请注意，你只从 endpoint pod 运行的那个节点得到了一个回复，这个回复有*正确的*客户端 IP。</p>
<p>这是发生的事情：</p>
<p>1、客户端发送数据包到 node2:nodePort，它没有任何 endpoints</p>
<p>2、数据包被丢弃</p>
<p>3、客户端发送数据包到 node1:nodePort，它*有*endpoints</p>
<p>4、node1 使用正确的源 IP 地址将数据包路由到 endpoint</p>
<p>形象的：<br> <img src="/2020/09/21/Kubernetes%E4%B8%AD%E7%9A%84Source-Ip%E6%9C%BA%E5%88%B6/1526622213101501.png" alt="avatar"></p>
<h2 id="Type-LoadBalancer-类型-Services-的-Source-IP"><a href="#Type-LoadBalancer-类型-Services-的-Source-IP" class="headerlink" title="Type=LoadBalancer 类型 Services 的 Source IP"></a>Type=LoadBalancer 类型 Services 的 Source IP</h2><p>      对于 Kubernetes 1.5，发送给类型为 Type=LoadBalancer Services 的数据包默认进行源地址 NAT，这是由于所有处于 Ready 状态的 Kubernetes 节点对于负载均衡的流量都是符合条件的。所以如果数据包到达一个没有 endpoint 的节点，系统将把这个包代理到有 endpoint 的节点，并替换数据包的源 IP 为节点的 IP（如前面章节所述）。</p>
<p>    你可以通过在一个 loadbalancer 上暴露这个 source-ip-app 来进行测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl expose deployment source-ip-app --name&#x3D;loadbalancer --port&#x3D;80 --target-port&#x3D;8080 --type&#x3D;LoadBalancer</span><br><span class="line">service &quot;loadbalancer&quot; exposed</span><br><span class="line">$ kubectl get svc loadbalancer</span><br><span class="line">NAME           CLUSTER-IP    EXTERNAL-IP       PORT(S)   AGE</span><br><span class="line">loadbalancer   10.0.65.118   104.198.149.140   80&#x2F;TCP    5m</span><br><span class="line">$ curl 104.198.149.140</span><br><span class="line">CLIENT VALUES:</span><br><span class="line">client\_address&#x3D;10.240.0.5</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>      然而，如果你的集群运行在 Google Kubernetes Engine/GCE 上，设置 service.spec.externalTrafficPolicy 字段值为 Local 可以强制使没有 endpoints 的节点把他们自己从负载均衡流量的可选节点名单中删除。这是通过故意使它们健康检查失败达到的。</p>
<p>形象的：<br> <img src="/2020/09/21/Kubernetes%E4%B8%AD%E7%9A%84Source-Ip%E6%9C%BA%E5%88%B6/1526622380157076.png" alt="avatar"></p>
<p>你可以设置 annotation 来进行测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl patch svc loadbalancer -p &#39;&#123;&quot;spec&quot;:&#123;&quot;externalTrafficPolicy&quot;:&quot;Local&quot;&#125;&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>你应该能够立即看到 Kubernetes 分配的 service.spec.healthCheckNodePort 字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get svc loadbalancer -o yaml | grep -i healthCheckNodePort</span><br><span class="line">  healthCheckNodePort: 32122</span><br></pre></td></tr></table></figure>

<p>service.spec.healthCheckNodePort 字段指向每个节点在 /healthz 路径上提供的用于健康检查的端口。你可以这样测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod -o wide -l run&#x3D;source-ip-app</span><br><span class="line">NAME                            READY     STATUS    RESTARTS   AGE       IP             NODE</span><br><span class="line">source-ip-app-826191075-qehz4   1&#x2F;1       Running   0          20h       10.180.1.136   kubernetes-minion-group-6jst</span><br><span class="line">kubernetes-minion-group-6jst $ curl localhost:32122&#x2F;healthz</span><br><span class="line">1 Service Endpoints found</span><br><span class="line">kubernetes-minion-group-jj1t $ curl localhost:32122&#x2F;healthz</span><br><span class="line">No Service Endpoints Found</span><br></pre></td></tr></table></figure>

<p>    主节点运行的 service 控制器负责分配 cloud loadbalancer。在这样做的同时，它也会分配指向每个节点的 HTTP 健康检查的 port/path。等待大约 10 秒钟之后，没有 endpoints 的两个节点的健康检查会失败，然后 curl 负载均衡器的 ip：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl 104.198.149.140</span><br><span class="line">CLIENT VALUES:</span><br><span class="line">client\_address&#x3D;104.132.1.79</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="跨平台支持"><a href="#跨平台支持" class="headerlink" title="跨平台支持"></a>跨平台支持</h2><p>     由于 Kubernetes 1.5 在类型为 Type=LoadBalancer 的 Services 中支持源 IP 保存的特性仅在 cloudproviders 的子集中实现（GCP and Azure）。你的集群运行的 cloudprovider 可能以某些不同的方式满足 loadbalancer 的要求：</p>
<p>1、使用一个代理终止客户端连接并打开一个到你的 nodes/endpoints 的新连接。在这种情况下，源 IP 地址将永远是云负载均衡器的地址而不是客户端的。</p>
<p>2、使用一个包转发器，因此从客户端发送到负载均衡器 VIP 的请求在拥有客户端源 IP 地址的节点终止，而不被中间代理。</p>
<p>      第一类负载均衡器必须使用一种它和后端之间约定的协议来和真实的客户端 IP 通信，例如 HTTP X-FORWARDED-FOR 头，或者 proxy 协议。 第二类负载均衡器可以通过简单的在保存于 Service 的 service.spec.healthCheckNodePort 字段上创建一个 HTTP 健康检查点来使用上面描述的特性。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/kubernetes-%E7%BD%91%E7%BB%9C/" rel="tag"># kubernetes 网络</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/09/21/Kubernetes-%E8%AF%A6%E8%A7%A3-%E7%AE%80%E4%BB%8B/" rel="prev" title="Kubernetes 详解--简介">
                  <i class="fa fa-chevron-left"></i> Kubernetes 详解--简介
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/09/21/Kubernetes-%E4%B8%AD%E7%9A%84port%E3%80%81nodePort%E3%80%81targetPort/" rel="next" title="Kubernetes 中的port、nodePort、targetPort">
                  Kubernetes 中的port、nodePort、targetPort <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">205k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:06</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
